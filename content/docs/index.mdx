---
title: Imgforge
---

imgforge is a fast, secure image proxy and transformation server built in Rust on top of libvips and Axum. It sits between your applications, a CDN, and the original image storage to resize, crop, convert formats, apply effects, and cache results on the fly.

- Performance-first: libvips and an async architecture deliver low latency and high throughput.
- Safe by default: signed URLs, optional bearer auth, and strict guards protect your origins.
- Operationally ready: metrics, structured logs, health endpoints, and predictable resource use.
- Familiar semantics: URL format is largely compatible with imgproxy, easing migrations.

## What problems imgforge solves

- Resize, crop, and convert images on demand without pre-generating variants.
- Reduce bandwidth and speed up pages by delivering modern formats (WebP/AVIF/HEIC) and right-sized images.
- Offload image IO and processing from your app servers to a dedicated service.
- Front a slow or rate-limited origin with a cacheable, CDN-friendly image layer.

## High-level architecture

```
┌────────────────────────────────────────────────────────────────────────┐
│                       imgforge Architecture                            │
└────────────────────────────────────────────────────────────────────────┘

  ┌─────────┐                                              ┌──────────────┐
  │   CDN   │◀────── Response (cached, global) ────────────│  End Users   │
  └────┬────┘                                              └──────┬───────┘
       │                                                          │
       │ Cache miss or bypass                                     │
       │                                                          │
       ▼                                                          │
  ┌───────────────────────────────────────────────────────────────┘
  │
  ▼
┌────────────────────────────────────────────────────────────────────┐
│                           imgforge                                 │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │  1. Verify HMAC signature (unless unsafe mode)               │  │
│  └───────────────────────────┬──────────────────────────────────┘  │
│                              │                                     │
│  ┌───────────────────────────▼──────────────────────────────────┐  │
│  │  2. Check cache (Memory/Disk/Hybrid) ───────┐                │  │
│  │                                       Hit?  │                │  │
│  └───────────────────────────┬─────────────────┘                │  │
│                              │ Miss                             │  │
│  ┌───────────────────────────▼──────────────────────────────────┐  │
│  │  3. Download source image (size/MIME validation)             │  │
│  └───────────────────────────┬──────────────────────────────────┘  │
│                              │                                     │
│  ┌───────────────────────────▼──────────────────────────────────┐  │
│  │  4. libvips Processing Pipeline:                             │  │
│  │     • Resize, crop, rotate                                   │  │
│  │     • Effects (blur, sharpen, pixelate)                      │  │
│  │     • Watermarking                                           │  │
│  │     • Format conversion (JPEG/WebP/AVIF/PNG)                 │  │
│  └───────────────────────────┬──────────────────────────────────┘  │
│                              │                                     │
│  ┌───────────────────────────▼──────────────────────────────────┐  │
│  │  5. Store in cache & serve response                          │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                    │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │  Metrics: /metrics (Prometheus)                              │  │
│  └──────────────────────────────────────────────────────────────┘  │
└────────────────────────────────────────────────────────────────────┘
       │                                  ▲
       │ Fetch original                   │
       ▼                                  │
  ┌─────────────────────┐                 │
  │  Origin Storage     │─────────────────┘
  │  (S3, HTTP, etc.)   │
  └─────────────────────┘
```

1. A client requests a transformation URL (usually generated by your app).
2. imgforge verifies the HMAC signature (unless explicitly allowed to use `unsafe`).
3. The server downloads the source image with size and MIME checks.
4. libvips applies the requested operations (resize, crop, blur/sharpen, watermarking, format conversion, etc.).
5. Results are served and optionally cached (memory, disk, or hybrid) for reuse.

## Security model at a glance

- HMAC-signed URLs are required by default; disable only for local development.
- Optional bearer authentication endpoints.
- Inbound fetch safeguards: allowed MIME types, maximum source size, and pixel resolution caps.
- Rate limiting and per-request guards stop abuse before it reaches your origin.

## Caching and performance

- Pluggable caches (memory, disk, or hybrid via Foyer) reduce repeated work.
- DPR-aware rendering and format negotiation minimize bytes on the wire.
- Tunable concurrency controls keep tail latencies predictable under load.

## What imgforge is not

- A general file server or CDN by itself. Pair it with a CDN or reverse proxy for TLS, caching, and global distribution.
- A digital asset management system. Use your existing storage and pipelines; imgforge focuses on transformation and delivery.

## Special thanks

imgforge is inspired by [imgproxy](https://github.com/imgproxy/imgproxy). So special thanks to the authors for their work!

Many thanks to the following open source projects that make imgforge possible:

- [libvips](https://github.com/libvips/libvips) for its powerful image processing library.
- [Foyer](https://github.com/josh-burton/foyer) for its fast, memory-efficient hybrid cache.
- [Axum](https://github.com/tokio-rs/axum) for its fast, async web framework.
- [Tokio](https://github.com/tokio-rs/tokio) for its async runtime.
- [Serde](https://github.com/serde-rs/serde) for its powerful data serialization framework.
- [Hyper](https://github.com/hyperium/hyper) for its HTTP client.
- [Tokio-stream](https://github.com/tokio-rs/tokio/tree/master/tokio-stream) for its streaming abstractions.
- [Tokio-util](https://github.com/tokio-rs/tokio/tree/master/tokio-util) for its utilities.
